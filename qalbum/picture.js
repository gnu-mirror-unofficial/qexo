// Copyright 2006, 2010 Per Bothner

// The following variables are defined in the document generated by qalbum:
// hash - the hash used for next/previous.
// style_link - one of "", "large", or "info" (matches filename)
var hidePreamble = false;
var up_button_link, prev_button_link, next_button_link,
  zoom_input_field, slider_button_link;
var hSize = 800, vSize = 600;
var scaleToFill = 1.0;
var imageRight = 0;
var imageBottom = 0;
var imageMoved = false;
var zoomInputFocused = false;
var navigationSubHash = "";

var zoom = "1.0"; // a number or "native"
function getHashParams(hash) {
  if (top.slider) hash = top.location.hash;
  if (hash) {
    var m = /zoom=([^,]*)/.exec(hash);
    if (m)
      zoom = m[1];
    m = /right=([^,]*)/.exec(hash);
    if (m)
      imageRight = m[1];
    m = /bottom=([^,]*)/.exec(hash);
    if (m)
      imageBottom = m[1];
    // Old: {medium,large}-scaled-only New: image-only
    m = /-only/.exec(hash);
    if (m)
      hidePreamble = true;
  }
}

getHashParams(hash);
var scaled = style_link != "info" && ! isNaN(Number(zoom));

function UpdateNavigationSubHash() {
  var str = hidePreamble ? "image-only" : "";
  if (zoom == "native")
    str = str + (str==""?"":",")+ "zoom=" + zoom;
  navigationSubHash = str;
}

function UpdateLocationHash() {
  UpdateNavigationSubHash();
  var str = "";
  if (hidePreamble) {
    if (str!="") str = str + ",";
    str = str + "image-only";
  }
  hash = str=="" ? "" : "#"+str; // hash to use for next/previous
  if (zoom == "native") {
    hash = hash=="" ? "#" : hash + ",";
    hash = hash + "zoom=" + zoom;
  }
  if (zoom != "1.0") {
    if (str!="") str = str + ",";
    str = str + "zoom=" + zoom;
  }
  if (imageRight != 0) {
    if (str!="") str = str + ",";
    str = str + "right=" + imageRight;
  }
  if (imageBottom != 0) {
    if (str!="") str = str + ",";
    str = str + "bottom=" + imageBottom;
  }
  location.hash = str == "" ? "" : "#" + str;
  uphash = hash; // FIXME ? hstr
  if (top.slider) {
    top.main.uphash = str;
    var oldhash = top.location.hash;
    var sl = oldhash.indexOf("/");
    if (sl > 0)
      oldhash = oldhash.substring(0, sl);
    if (str != "")
      str = oldhash + '/' + str;

    top.location.hash = str;
  }

  if (zoom_input_field)
    zoom_input_field.value = zoom;
}

function addStyleRule(sel, spec) {
  var stylesheet = document.styleSheets[1];
  if (stylesheet.insertRule)
    stylesheet.insertRule(sel+" {"+spec+"}", 0);
  else if (stylesheet.addRule)
    stylesheet.addRule(sel, spec);
}
//if (scaled) {
  // We want to disable the initial display of the image as it is loaded,
  // before it gets scaled, to avoid (slow) flicker.
  // We add a rule to the dynamic stylesheet to do this.
  // We add the rule using JavaScript since we only want to disable the
  // initial display when JavaScript is enabled.
  addStyleRule("img#main-image", "visibility: hidden");
//}
addStyleRule("span#slider-button", "display: inline-block");
addStyleRule("span#zoom-buttons", "display: inline-block");

function stopPropagation(e) {
  if (!e) var e = window.event;
  e.cancelBubble = true;
  if (e.stopPropagation) e.stopPropagation();
  return true;
}

function SliderFixLink(link, target) {
  registerOnClick(link, function(evt) {
      top.slider.sliderSelectId(target);
      stopPropagation(evt);
      if (evt.preventDefault)
        evt.preventDefault();
      evt.returnValue = false;
      return false;
    });
  link.href = "slider.html#"+target;
}

function StyleFixLinks() {
  var links = document.getElementsByTagName("a");
  if (top.slider) {
    if (up_button_link) {
      var tophash = top.location.hash;
      var sl = tophash.indexOf("/");
      var uplink = "index.html#slider"+(sl <= 0 ? "" : ("-"+tophash.substring(sl+1)));
      up_button_link.setAttribute('onclick', "top.location='"+uplink+"'");
      up_button_link.href = uplink;
    }
    var slashTail = hash && hash.length > 1 && hash[0] == '#'
	  ? "/" + hash.substring(1) : "";
    if (prev_button_link)
      SliderFixLink(prev_button_link, prevId+style_link+slashTail);

    if (next_button_link)
      SliderFixLink(next_button_link, nextId+style_link+slashTail);

    if (slider_button_link) {
      slider_button_link.href = thisId+style_link+".html"+hash;
      var slider_child = slider_button_link.firstChild;
      if (slider_child && ! slider_child.nextSibling
          && slider_child.nodeType == 3)
	slider_child.data = "Hide slider";
      registerOnClick(slider_button_link,
         function(evt) {
           top.location = slider_button_link.href;
           return false;
         });
    }
    for (var i = links.length; --i >= 0; ) {
      var bstyle = links[i].parentNode.getAttribute("style-button");
      if (bstyle) {
        if (bstyle=="medium")
           bstyle = "";
        SliderFixLink(links[i], thisId+bstyle+slashTail);
      }
    }
    links = top.slider.document.getElementsByTagName("a");
    for (var i = links.length; --i >= 0; ) {
      if (links[i].getAttribute("fixup")) {
        var href = links[i].href;
        var ind = href.indexOf("#");
        if (ind > 0 && (ind = href.indexOf("/", ind)) > 0)
          href = href.substring(0, ind);
        var m = /(.*)info$/.exec(href);
        if (m)
          href = m[1];
        m = /(.*)large$/.exec(href);
        if (m)
          href = m[1];

        href = href + style_link;
        links[i].href = href+slashTail;
      }
    }
  }
  else { // Not slider
    if (up_button_link)
      up_button_link.href = "index.html"+uphash;
    if (prev_button_link)
      prev_button_link.hash = hash;
    if (next_button_link)
      next_button_link.hash = hash;
    for (var i = links.length; --i >= 0; ) {
      var bstyle = links[i].parentNode.getAttribute("style-button");
      if (bstyle) {
        registerOnClick(links[i].parentNode, stopPropagation);
      }
    }
  }
}

function registerOnClick(node, handler) {
  if (node) {
    if (node.addEventListener)
      node.addEventListener('click', handler, false);
    else
      node.onclick = handler;
  }
}

function OnLoad() {
  up_button_link = document.getElementById("up-link");
  prev_button_link = document.getElementById("prev-link");
  next_button_link = document.getElementById("next-link");
  slider_button_link = document.getElementById("slider-link");
  zoom_input_field = document.getElementById("zoom-input-field");
  if (zoom_input_field)
    zoom_input_field.value = zoom;
  if (prev_button_link)
    registerOnClick(prev_button_link.parentNode, stopPropagation);
  if (next_button_link)
    registerOnClick(next_button_link.parentNode, stopPropagation);
  registerOnClick(up_button_link.parentNode, stopPropagation);
  registerOnClick(slider_button_link.parentNode, stopPropagation);
  UpdateNavigationSubHash();
  StyleFixLinks();
  preamble = document.getElementById("preamble");
  ScaledLoad();
  image.style.visibility = "visible";
}

function ImageClickHandler(evt) {
  if (!evt) var evt = window.event;
  if (imageMoved)
    return false;
  // If clicking in the rightmost 20% go to next.
  if (5 * evt.clientX >= 4 * hSize) {
    if (nextId) {
      if (top.slider)
        top.slider.sliderSelectCurStyle(nextId);
      else
        location=nextId+style_link+".html"+hash;
    }
    else if (hidePreamble)
      toggleHidePreamble();
  }
  // If clicking in the lefttmost 20% go to prev.
  else if (5 * evt.clientX <= hSize) {
    if (prevId) {
      if (top.slider)
	top.slider.sliderSelectCurStyle(prevId);
      else
        location=prevId+style_link+".html"+hash;
    }
    else if (hidePreamble)
      toggleHidePreamble();
  }
  else {
    toggleHidePreamble();
  }
  imageMoved = false;
  return false;
}

// From http://www.experts-exchange.com/articles/Programming/Languages/Scripting/JavaScript/Mouse-Wheel-Programming-in-JavaScript.html
function OnMouseWheelSpin(e) {
    var nDelta = 0;
    if (!e) { // For IE, access the global (window) event object
        e = window.event;
    }
    // cross-bowser handling of eventdata to boil-down delta (+1 or -1)
    if ( e.wheelDelta ) { // IE and Opera
        nDelta= e.wheelDelta;
        if ( window.opera ) {  // Opera has the values reversed
            nDelta= -nDelta;
        }
    }
    else if (e.detail) { // Mozilla FireFox
        nDelta= -e.detail;
    }
    if (nDelta > 0) {
        HandleZoomClick( 1, e.clientX, e.clientY );
    }
    if (nDelta < 0) {
        HandleZoomClick( -1, e.clientX, e.clientY );
    }
    if ( e.preventDefault ) {  // Mozilla FireFox
        e.preventDefault();
    }
    e.returnValue = false;  //
}
function ZoomIn(event) {
   if (!event) event = window.event;
   stopPropagation(event);
   HandleZoom(2);
  // if (event.stopPropagation) event.stopPropagation();  // DOM Level 2
  //   else event.cancelBubble = true;                      // IE
  return false;
}

function ZoomOut(event) {
   if (!event) event = window.event;
   stopPropagation(event);
   //if (event.stopPropagation) event.stopPropagation();  // DOM Level 2
   //else event.cancelBubble = true;                      // IE
   HandleZoom(-2);
}

/* Handler when zoom_input_field is changed. */
function ZoomChange(event) {
  if (!event) event = window.event;
  zoom = zoom_input_field.value;
  // if (event.stopPropagation) event.stopPropagation();  // DOM Level 2
  // else event.cancelBubble = true;                      // IE
  // Now prevent any default action.
  if (event.preventDefault) event.preventDefault();   // DOM Level 2
  else event.returnValue = false;                     // IE
  HandleZoom(0);
  return false;
}

function HandleZoom(nDelta) {
  // Simulate HandleZoomClick event at center of image.
  // That seems to yield reasonable centering.
  var zm = Number(zoom);
  var scale = isNaN(zm) ? 1.0 : zm * scaleToFill;
  var centerx = hSize - imageRight - 0.5 * scale * image.origwidth;
  var centery = vSize - imageBottom - 0.5 * scale * image.origheight;
  HandleZoomClick(nDelta, centerx, centery);
}
function HandleZoomClick(nDelta, x, y) {
    var zm = Number(zoom);
    var scale;
    var wasScaled = scaled;
    if (isNaN(zm) && nDelta != 0) {
      zm = 1.0/scaleToFill;
      zoom = zm.toFixed(1);
      scaled = true;
    }
    if (! isNaN(zm)) {
        var oldzm = zm;
        zm += nDelta * 0.1;
        if (zm < 0.1)
          zm = 0.1;
        if (zm > 100)
          zm = 100;
        var zoomin = zm/oldzm;
        zoom = zm.toFixed(1);
        // distance from click to image right/bottom border
        var dx = hSize - x - imageRight;
        var dy = vSize - y - imageBottom;
        imageRight = Math.round(hSize - x - dx * zoomin);
        imageBottom = Math.round(vSize - y - dy * zoomin);
        scale = zm * scaleToFill;
    } else {
      scale = 1.0;
      imageRight = 0;
      imageBottom = 0;
      scaled = false;
    }
    image.style.width = (scale * image.origwidth) + "px";
    image.style.height = (scale * image.origheight) + "px";
    image.style.right=imageRight+"px";
    image.style.bottom=imageBottom+"px";
    UpdateLocationHash();
    if (scaled!=wasScaled)
      StyleFixLinks();
}

var image, preamble;

function OnMouseDown(e) {
   if (!e) e = window.event;  // IE Event Model
   drag(image,e);
}

function ScaledLoad() {
  var body = preamble.parentNode;
  body.style.overflow = "hidden";
  image = document.getElementById("main-image");
  var zoomInButton = document.getElementById("zoom-in-button");
  var zoomOutButton = document.getElementById("zoom-out-button");
  // FIXME Don't set ImageClickHandler, OnMouseWheelSpin etc in Info mode.
  registerOnClick(document, ImageClickHandler);
  registerOnClick(zoomInButton, ZoomIn);
  registerOnClick(zoomOutButton, ZoomOut);
  //FIXME use registerOnClick
  if (image.addEventListener) {
    image.addEventListener('DOMMouseScroll', OnMouseWheelSpin, false);
    image.addEventListener('mousewheel', OnMouseWheelSpin, false); // Chrome
    image.addEventListener('mousedown', OnMouseDown, false);
    if (zoom_input_field)
      zoom_input_field.addEventListener('change', ZoomChange, false);
      zoom_input_field.addEventListener('focus',
	function(evt) {zoomInputFocused = true;}, false);
      zoom_input_field.addEventListener('blur',
	function(evt) {zoomInputFocused = false;}, false);
      registerOnClick(zoom_input_field, stopPropagation);
  }
  else {
//    image.onmousewheel= OnMouseWheelSpin;
    // ...
  }
  image.style.position="absolute";
  image.style.right=imageRight+"px";
  image.style.bottom=imageBottom+"px";

  image.origwidth = image.getAttribute("width");
  image.origheight = image.getAttribute("height");
  image.style.border = "0px";
  //image.style.padding = "0px";
  preamble.style.position="absolute";
  preamble.style.visibility = hidePreamble ? "hidden" : "visible";
  ScaledResize();
  image.style.visibility = "visible";
}

function ScaledResize() {
  /* Window size calculation from S5 slides.css. by Eric Meyer. */
  if (window.innerHeight) {
    vSize = window.innerHeight;
    hSize = window.innerWidth;
  } else if (document.documentElement.clientHeight) {
    vSize = document.documentElement.clientHeight;
    hSize = document.documentElement.clientWidth;
  } else if (document.body.clientHeight) {
    vSize = document.body.clientHeight;
    hSize = document.body.clientWidth;
  } else {
    vSize = 700;  // assuming 1024x768, minus chrome and such
    hSize = 1024; // these do not account for kiosk mode or Opera Show
  }
  var wscale = hSize /  image.origwidth;
  var hscale = vSize / image.origheight;
  scaleToFill = Math.min(wscale, hscale);

  if (! scaled)
    return;
  var zm = Number(zoom);
  var scale = isNaN(zm) ? 1.0 : zm * scaleToFill;
  image.style.width = (scale * image.origwidth) + "px";
  image.style.height = (scale * image.origheight) + "px";
}

function handler(e) {
  var event = e ? e : window.event;
  var key = event.keyCode ? event.keyCode : event.which;
  if (event.ctrlKey || event.altKey || event.metaKey || zoomInputFocused)
    return;
  var shifted;
  if (key >= 65 && key <= 90) { key += 32; shifted = true; }
  else if (event.shiftKey) shifted = true;
  if (key == 32 || key == 34) { // space or page-down
    var body = document.body;
    if (nextId && body.scrollTop+body.clientHeight>=body.scrollHeight)
      key = 110;
    else
      return true;
  }
  if (nextId && key == 110) { // 'n' key
      if (top.slider) {
        top.slider.sliderSelectCurStyle(nextId);
        return false;
      }
      location=nextId+style_link+".html"+hash;
      return true;
  }
  if (key == 33) { // page-up
    var body = document.body;
    if (prevId && body.scrollTop==0)
      key = 112;
    else
      return true;
  }
  if (prevId && key == 112) { // 'p' key
      if (top.slider) {
        top.slider.sliderSelectCurStyle(prevId);
        return false;
      }
    location=prevId+style_link+".html"+hash; return true;
  }
  if (key == 117) /* u==Up */ { top.location="index.html"+uphash; return true; }
  if (key == 115) /* 's' */ {
    location="slider.html#"+thisId+(shifted ? "/large-scaled" : "/medium-scaled");
    return true; }
  if (key == 105) /* 'i' */ { location=thisId+"info.html"; return true; }
  if (key == 108) /* 'l' */ { location=thisId+"large.html#large-scaled"; return true; }
  if (key == 109) /* 'm' */ { location=thisId+".html"; return true; }
  if (key == 104 ) { /* 'h' */
    toggleHidePreamble();
    return true;
  }
}

function toggleHidePreamble() {
  hidePreamble = !hidePreamble;
  preamble.style.visibility = hidePreamble ? "hidden" : "visible";
  UpdateLocationHash();
  StyleFixLinks();
}

document.onkeypress = handler;

// No longer used - only so old pages don't die.
function StyleMenu() { return ""; }

// FIXME
//document.write("<style>span[style-button] { display: none }</style>");

// FIXME - add credit
function drag(elementToDrag, event) {
    // The mouse position (in window coordinates)
    // at which the drag begins 
    var startX = event.clientX, startY = event.clientY;    

    // The original position (in document coordinates) of the
    // element that is going to be dragged.  Since elementToDrag is 
    // absolutely positioned, we assume that its offsetParent is the
    // document body.
    var origX = elementToDrag.offsetLeft, origY = elementToDrag.offsetTop;

    // Even though the coordinates are computed in different 
    // coordinate systems, we can still compute the difference between them
    // and use it in the moveHandler() function.  This works because
    // the scrollbar position never changes during the drag.
    var deltaX = startX - origX, deltaY = startY - origY;

    // Register the event handlers that will respond to the mousemove events
    // and the mouseup event that follow this mousedown event.  
    if (document.addEventListener) {  // DOM Level 2 event model
        // Register capturing event handlers
        document.addEventListener("mousemove", moveHandler, true);
        document.addEventListener("mouseup", upHandler, true);
    }
    else if (document.attachEvent) {  // IE 5+ Event Model
        // In the IE event model, we capture events by calling
        // setCapture() on the element to capture them.
        elementToDrag.setCapture();
        elementToDrag.attachEvent("onmousemove", moveHandler);
        elementToDrag.attachEvent("onmouseup", upHandler);
        // Treat loss of mouse capture as a mouseup event
        elementToDrag.attachEvent("onlosecapture", upHandler);
    }
    else {  // IE 4 Event Model
        // In IE 4 we can't use attachEvent() or setCapture(), so we set
        // event handlers directly on the document object and hope that the
        // mouse events we need will bubble up.  
        var oldmovehandler = document.onmousemove; // used by upHandler() 
        var olduphandler = document.onmouseup;
        document.onmousemove = moveHandler;
        document.onmouseup = upHandler;
    }

    // We've handled this event. Don't let anybody else see it.  
    if (event.stopPropagation) event.stopPropagation();  // DOM Level 2
    else event.cancelBubble = true;                      // IE

    // Now prevent any default action.
    if (event.preventDefault) event.preventDefault();   // DOM Level 2
    else event.returnValue = false;                     // IE

    imageMoved = false;

    /**
     * This is the handler that captures mousemove events when an element
     * is being dragged. It is responsible for moving the element.
     **/
    function moveHandler(e) {
        if (!e) e = window.event;  // IE Event Model

        // Move the element to the current mouse position, adjusted as
        // necessary by the offset of the initial mouse-click.
        imageRight -= e.clientX - startX;
        startX = e.clientX;
        imageBottom -= e.clientY - startY;
        startY = e.clientY;
        image.style.right=imageRight+"px";
        image.style.bottom=imageBottom+"px";
        //UpdateLocationHash();
        //elementToDrag.style.left = (e.clientX - deltaX) + "px";
        //elementToDrag.style.top = (e.clientY - deltaY) + "px";

        stopPropagation(e);
        // And don't let anyone else see this event.
        //if (e.stopPropagation) e.stopPropagation();  // DOM Level 2
        //else e.cancelBubble = true;                  // IE
        imageMoved = true;
        UpdateLocationHash();
    }

    /**
     * This is the handler that captures the final mouseup event that
     * occurs at the end of a drag.
     **/
    function upHandler(e) {
        if (!e) e = window.event;  // IE Event Model

        // Unregister the capturing event handlers.
        if (document.removeEventListener) {  // DOM event model
            document.removeEventListener("mouseup", upHandler, true);
            document.removeEventListener("mousemove", moveHandler, true);
        }
        else if (document.detachEvent) {  // IE 5+ Event Model
            elementToDrag.detachEvent("onlosecapture", upHandler);
            elementToDrag.detachEvent("onmouseup", upHandler);
            elementToDrag.detachEvent("onmousemove", moveHandler);
            elementToDrag.releaseCapture();
        }
        else {  // IE 4 Event Model
            // Restore the original handlers, if any
            document.onmouseup = olduphandler;
            document.onmousemove = oldmovehandler;
        }

        // And don't let the event propagate any further.
        if (e.stopPropagation) e.stopPropagation();  // DOM Level 2
        else e.cancelBubble = true;                  // IE
    }
}
