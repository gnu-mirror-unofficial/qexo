// Copyright 2006, 2010, 2011, 2014, 2020 Per Bothner
"use strict";
// The following variables are defined in the document generated by qalbum:
// hash - the hash used for next/previous.
// style_link - one of "", "large", or "info" (matches filename)
var hidePreamble = false;
var up_button_link, prev_button_link, next_button_link,
  zoom_input_field, slider_button_link;
var hSize = 800, vSize = 600;
var scaleToFill = 1.0;
var imageRight = 0;
var imageBottom = 0;
var imageMoved = false;
var zoomInputFocused = false;
var modCount = 0;
var image; // set by OnLoad
var preamble;
var evCache = new Array();
var startX, startY, origX, origY, deltaX, deltaY;
var prevDiff = -1, prevCenterX = -1, prevCenterY = -1;;

var zoomn = 1.0; // A real scale factor or NaN (as "native")
// 1.0 scales the image to fully fit the available space.
var zoom = "1.0"; // zoomn.toFixed(1) or "native"
var navigationSubHash = "";

// Set/reset zoom, imageRight, imageBottom, hidePreamble from zoom.
function getHashParams(hash) {
  if (top.slider) hash = top.location.hash;
  var m = /zoom=([^,]*)/.exec(hash);
  zoom = m ? m[1] : "1.0";
  m = /right=([^,]*)/.exec(hash);
  imageRight = m ? m[1] : 0;
  m = /bottom=([^,]*)/.exec(hash);
  imageBottom = m ? m[1] : 0;
  // Old: {medium,large}-scaled-only New: image-only
  m = /-only/.exec(hash);
  hidePreamble = m ? true : false;
}

getHashParams(hash);
var scaled = style_link != "info" && ! isNaN(zoomn);

function UpdateNavigationSubHash() {
  var str = hidePreamble ? "image-only" : "";
  if (zoom == "native")
    str = str + (str==""?"":",")+ "zoom=" + zoom;
  navigationSubHash = str;
}

function UpdateLocationHash() {
  UpdateNavigationSubHash();
  var str = "";
  if (hidePreamble) {
    if (str!="") str = str + ",";
    str = str + "image-only";
  }
  hash = str=="" ? "" : "#"+str; // hash to use for next/previous
  if (zoom == "native") {
    hash = hash=="" ? "#" : hash + ",";
    hash = hash + "zoom=" + zoom;
  }
  if (zoom != "1.0") {
    if (str!="") str = str + ",";
    str = str + "zoom=" + zoom;
  }
  if (imageRight != 0) {
    if (str!="") str = str + ",";
    str = str + "right=" + imageRight;
  }
  if (imageBottom != 0) {
    if (str!="") str = str + ",";
    str = str + "bottom=" + imageBottom;
  }
  if (++modCount > 1)
    location.replace(str=="" ? "" : "#" + str);
  else
    location.hash = str=="" ? "" : "#" + str;
  uphash = hash; // FIXME ? hstr
  if (top.slider) {
    top.main.uphash = str;
    var oldhash = top.location.hash;
    var sl = oldhash.indexOf("/");
    if (sl > 0)
      oldhash = oldhash.substring(0, sl);
    if (str != "")
      str = oldhash + '/' + str;

    top.location.hash = str;
  }

  if (zoom_input_field)
    zoom_input_field.value = zoom;
}

function addStyleRule(sel, spec) {

  var stylesheet = document.styleSheets[1];

  if (stylesheet.insertRule)
    stylesheet.insertRule(sel+" {"+spec+"}", 0);
  else if (stylesheet.addRule)
    stylesheet.addRule(sel, spec);
}

//if (scaled) {
  // We want to disable the initial display of the image as it is loaded,
  // before it gets scaled, to avoid (slow) flicker.
  // We add a rule to the dynamic stylesheet to do this.
  // We add the rule using JavaScript since we only want to disable the
  // initial display when JavaScript is enabled.
  addStyleRule("img#main-image", "visibility: hidden");
//}
addStyleRule("span#slider-button", "display: inline-block");
addStyleRule("span#zoom-buttons", "display: inline-block");

function stopPropagation(e) {
  if (!e) e = window.event;
  if (e.stopPropagation) e.stopPropagation();
  else e.cancelBubble = true;
  return true;
}

function SliderFixLink(link, target) {
  registerOnClick(link, function(evt) {
      top.slider.sliderSelectId(target);
      stopPropagation(evt);
      evt.preventDefault();
      evt.returnValue = false;
      return false;
    });
  link.href = "slider.html#"+target;
}

function HashChanged(event) {
    getHashParams(location.hash);
    UpdateImage();
}

function StyleFixLinks() {
  var links = document.getElementsByTagName("a");
  if (top.slider) {
    if (up_button_link) {
      var tophash = top.location.hash;
      var sl = tophash.indexOf("/");
      var uplink = "index.html#slider"+(sl <= 0 ? "" : ("-"+tophash.substring(sl+1)));
      up_button_link.setAttribute('onclick', "top.location='"+uplink+"'");
      up_button_link.href = uplink;
    }
    var slashTail = hash && hash.length > 1 && hash[0] == '#'
	  ? "/" + hash.substring(1) : "";
    if (prev_button_link)
      SliderFixLink(prev_button_link, prevId+style_link+slashTail);

    if (next_button_link)
      SliderFixLink(next_button_link, nextId+style_link+slashTail);

    if (slider_button_link) {
      slider_button_link.href = thisId+style_link+".html"+hash;
      var slider_child = slider_button_link.firstChild;
      if (slider_child && ! slider_child.nextSibling
          && slider_child.nodeType == 3)
	slider_child.data = "Hide slider";
      registerOnClick(slider_button_link,
         function(evt) {
           top.location = slider_button_link.href;
           return false;
         });
    }
    for (var i = links.length; --i >= 0; ) {
        var bstyle = links[i].parentNode.getAttribute("style-button");
        if (bstyle) {
          var linkRef = links[i].href;
          var m = linkRef && linkRef.match(/.*(medium|large|info)[.]html$/);
          SliderFixLink(links[i], thisId + (m ? m[1] : "") + slashTail);
        }
    }
    links = top.slider.document.getElementsByTagName("a");
    for (var i = links.length; --i >= 0; ) {
      if (links[i].getAttribute("fixup")) {
        var href = links[i].href;
        var ind = href.indexOf("#");
        if (ind > 0 && (ind = href.indexOf("/", ind)) > 0)
          href = href.substring(0, ind);
        var m = /(.*)(info|medium|large)$/.exec(href);
        if (m)
          href = m[1];
        href = href + style_link;
        links[i].href = href+slashTail;
      }
    }
  }
  else { // Not slider
    if (up_button_link)
      up_button_link.href = "index.html"+uphash;
    if (prev_button_link)
      prev_button_link.hash = hash;
    if (next_button_link)
      next_button_link.hash = hash;
    for (var i = links.length; --i >= 0; ) {
      var bstyle = links[i].parentNode.getAttribute("style-button");
      if (bstyle) {
        registerOnClick(links[i].parentNode, stopPropagation);
      }
    }
  }
}

function registerOnClick(node, handler) {
  if (node) {
    if (node.addEventListener)
      node.addEventListener('click', handler, false);
    else
      node.onclick = handler;
  }
}

function OnLoad() {
  image = document.getElementById("main-image");
  if (image == null) { // for "info" style get thumb element.
    let imgs = document.getElementsByTagName("img");
    if (imgs.length == 1)
      image = imgs[0];
  }
  up_button_link = document.getElementById("up-link");
  prev_button_link = document.getElementById("prev-link");
  next_button_link = document.getElementById("next-link");
  slider_button_link = document.getElementById("slider-link");
  zoom_input_field = document.getElementById("zoom-input-field");
  if (zoom_input_field)
    zoom_input_field.value = zoom;
  if (prev_button_link)
    registerOnClick(prev_button_link.parentNode, stopPropagation);
  if (next_button_link)
    registerOnClick(next_button_link.parentNode, stopPropagation);
  registerOnClick(document.getElementById("zoom-in-button"), ZoomIn);
  registerOnClick(document.getElementById("zoom-out-button"), ZoomOut);
  registerOnClick(up_button_link.parentNode, stopPropagation);
  registerOnClick(slider_button_link.parentNode, stopPropagation);
  if (window.addEventListener)
     window.addEventListener("hashchange", HashChanged, false);
  UpdateNavigationSubHash();
  StyleFixLinks();
  preamble = document.getElementById("preamble");
  if (style_link != "info")
    ScaledLoad();
  image.style.visibility = "visible";
}

function ImageClickHandler(evt) {
  if (!evt) var evt = window.event;
  if (imageMoved)
    return false;
  // If clicking in the rightmost 20% go to next.
  if (5 * evt.clientX >= 4 * hSize) {
    if (nextId) {
      if (top.slider)
        top.slider.sliderSelectCurStyle(nextId);
      else
        location=nextId+style_link+".html"+hash;
    }
    else if (hidePreamble)
      toggleHidePreamble();
  }
  // If clicking in the lefttmost 20% go to prev.
  else if (5 * evt.clientX <= hSize) {
    if (prevId) {
      if (top.slider)
	top.slider.sliderSelectCurStyle(prevId);
      else
        location=prevId+style_link+".html"+hash;
    }
    else if (hidePreamble)
      toggleHidePreamble();
  }
  else {
    toggleHidePreamble();
  }
  imageMoved = false;
  return false;
}

// From http://www.experts-exchange.com/articles/Programming/Languages/Scripting/JavaScript/Mouse-Wheel-Programming-in-JavaScript.html
function OnMouseWheelSpin(e) {
    var nDelta = 0;
    if (!e) { // For IE, access the global (window) event object
        e = window.event;
    }
    // cross-bowser handling of eventdata to boil-down delta (+1 or -1)
    if ( e.wheelDelta ) { // IE and Opera
        nDelta= e.wheelDelta;
        if ( window.opera ) {  // Opera has the values reversed
            nDelta= -nDelta;
        }
    }
    else if (e.detail) { // Mozilla FireFox
        nDelta= -e.detail;
    }
    if (nDelta > 0) {
        HandleZoomClick( 1, e.clientX, e.clientY );
    }
    if (nDelta < 0) {
        HandleZoomClick( -1, e.clientX, e.clientY );
    }
    e.preventDefault();
}
function ZoomIn(event) {
  HandleZoom(2);
  if (event) {
      event.preventDefault();
      event.stopPropagation();
  }
}

function ZoomOut(event) {
  HandleZoom(-2);
  if (event) {
      event.preventDefault();
      event.stopPropagation();
  }
}

/* Handler when zoom_input_field is changed. */
function ZoomChange(event) {
  if (!event) event = window.event;
  zoom = zoom_input_field.value;
  // if (event.stopPropagation) event.stopPropagation();  // DOM Level 2
  // else event.cancelBubble = true;                      // IE
  event.preventDefault();
  HandleZoom(0);
  return false;
}

function HandleZoom(nDelta) {
  // Simulate HandleZoomClick event at center of image.
  // That seems to yield reasonable centering.
  var scale = isNaN(zoomn) ? 1.0 : zoomn * scaleToFill;
  var centerx = hSize - imageRight - 0.5 * scale * image.origwidth;
  var centery = vSize - imageBottom - 0.5 * scale * image.origheight;
  HandleZoomClick(nDelta, centerx, centery);
}
function HandleZoomClick(nDelta, x, y) {
    var scale;
    var wasScaled = scaled;
    if (isNaN(zoomn) && nDelta != 0) {
      zoomn = 1.0/scaleToFill;
      zoom = zm.toFixed(1);
      scaled = true;
    }
    if (! isNaN(zoomn)) {
        var oldzm = zoomn;
        zoomn += nDelta * 0.1;
        if (zoomn < 0.1)
          zoomn = 0.1;
        if (zoomn > 100)
          zoomn = 100;
        var zoomin = zoomn/oldzm;
        zoom = zoomn.toFixed(1);
        // distance from click to image right/bottom border
        var dx = hSize - x - imageRight;
        var dy = vSize - y - imageBottom;
        imageRight = Math.round(hSize - x - dx * zoomin);
        imageBottom = Math.round(vSize - y - dy * zoomin);
    }
    UpdateImage();
    UpdateLocationHash();
    if (scaled!=wasScaled)
      StyleFixLinks();
}

function UpdateImage() {
    var scale;
    if (! isNaN(zoomn)) {
        scale = zoomn * scaleToFill;
    } else {
      scale = 1.0;
      imageRight = 0;
      imageBottom = 0;
      scaled = false;
    }
    image.style.width = (scale * image.origwidth) + "px";
    image.style.height = (scale * image.origheight) + "px";
    image.style.right=imageRight+"px";
    image.style.bottom=imageBottom+"px";
}

//remove_event(ev);

function downHandler(ev) {
    if (evCache.length == 0)
        image.addEventListener("pointermove", moveHandler, false);
    evCache.push(ev);
    drag(image, ev);
    //ev.preventDefault();
}

function upHandler(ev) {
    // Unregister the capturing event handlers.
    //document.removeEventListener("pointerup", upHandler, true);
     if ( pendingUpdateAfterMove) {
         pendingUpdateAfterMove = false;
         clearTimeout(updateAfterMove);
         updateAfterMove();
     }

    for (var i = 0; i < evCache.length; i++) {
        if (evCache[i].pointerId == ev.pointerId) {
            evCache.splice(i, 1);
            break;
        }
    }
    // If the number of pointers down is less than two then reset diff tracker
    if (evCache.length < 2) prevDiff = -1;
    // And don't let the event propagate any further.
    if (evCache.length == 0)
        image.removeEventListener("pointermove", moveHandler, false);
    ev.stopPropagation();
}

function moveHandler(ev) {
    // Find this event in the cache and update its record with this event
    for (var i = 0; i < evCache.length; i++) {
        if (ev.pointerId == evCache[i].pointerId) {
            evCache[i] = ev;
            break;
        }
    }
    if (! pendingUpdateAfterMove) {
        pendingUpdateAfterMove = true;
        setTimeout(updateAfterMove, 100);
    }
    //updateAfterMove();
    ev.preventDefault();
    ev.stopPropagation();
}
var pendingUpdateAfterMove = false;

function updateAfterMove() {
    pendingUpdateAfterMove = false;
    if (evCache.length == 1) {
        let ev = evCache[0]
        // Move the element to the current mouse position, adjusted as
        // necessary by the offset of the initial mouse-click.
        imageRight -= ev.clientX - startX;
        startX = ev.clientX;
        imageBottom -= ev.clientY - startY;
        startY = ev.clientY;
        image.style.right=imageRight+"px";
        image.style.bottom=imageBottom+"px";
        stopPropagation(ev);
        imageMoved = true;
        UpdateLocationHash();
    } else if (evCache.length == 2) {
        let curDiffX = Math.abs(evCache[0].clientX - evCache[1].clientX);
        let curDiffY = Math.abs(evCache[0].clientY - evCache[1].clientY);
        let curCenterX = 0.5 * evCache[0].clientX + 0.5 * evCache[1].clientX;
        let curCenterY = 0.5 * evCache[0].clientY + 0.5 * evCache[1].clientY;
        let curDiff = 0.5 * curDiffX + 0.5 * curDiffY;
        let oldzm = zoomn;
        if (prevDiff > 0 && ! isNaN(oldzm)) {
            var wasScaled = scaled;
            var zoomin = curDiff / prevDiff;
            zoomn = oldzm * zoomin;
            zoom = zoomn.toFixed(1);
            imageRight = hSize - curCenterX - zoomin * (hSize - prevCenterX - imageRight);
            imageBottom = vSize - curCenterY - zoomin * (vSize - prevCenterY - imageBottom);
            UpdateImage();
            UpdateLocationHash();
            if (scaled!=wasScaled)
                StyleFixLinks();
        }
        prevDiff = curDiff;
        prevCenterX = curCenterX;
        prevCenterY = curCenterY;
    }
}

function ScaledLoad() {
  var body = preamble.parentNode;
  body.style.overflow = "hidden";
  var zoomInButton = document.getElementById("zoom-in-button");
  var zoomOutButton = document.getElementById("zoom-out-button");
  // FIXME Don't set ImageClickHandler, OnMouseWheelSpin etc in Info mode.
  registerOnClick(document, ImageClickHandler);
  registerOnClick(zoomInButton, ZoomIn);
  registerOnClick(zoomOutButton, ZoomOut);

    image.addEventListener('DOMMouseScroll', OnMouseWheelSpin, false);
    image.addEventListener('mousewheel', OnMouseWheelSpin, false); // Chrome
    image.addEventListener('pointerdown', downHandler, false);
    image.addEventListener("pointerup", upHandler, true);
    image.addEventListener("pointercancel", upHandler, true);
    image.addEventListener("pointerout", upHandler, true);
    image.addEventListener("pointerleave", upHandler, true);
    if (zoom_input_field)
        zoom_input_field.addEventListener('change', ZoomChange, false);
    zoom_input_field.addEventListener('focus',
	                              function(evt) {zoomInputFocused = true;}, false);
    zoom_input_field.addEventListener('blur',
	                              function(evt) {zoomInputFocused = false;}, false);
    registerOnClick(zoom_input_field, stopPropagation);

  image.style.position="absolute";
  image.style.right=imageRight+"px";
  image.style.bottom=imageBottom+"px";

  image.origwidth = image.getAttribute("width");
  image.origheight = image.getAttribute("height");
  image.style.border = "0px";
  //image.style.padding = "0px";
  preamble.style.position="absolute";
  preamble.style.visibility = hidePreamble ? "hidden" : "visible";
  ScaledResize();
  image.style.visibility = "visible";
}

function ScaledResize() {
  /* Window size calculation from S5 slides.css. by Eric Meyer. */
  if (window.innerHeight) {
    vSize = window.innerHeight;
    hSize = window.innerWidth;
  } else if (document.documentElement.clientHeight) {
    vSize = document.documentElement.clientHeight;
    hSize = document.documentElement.clientWidth;
  } else if (document.body.clientHeight) {
    vSize = document.body.clientHeight;
    hSize = document.body.clientWidth;
  } else {
    vSize = 700;  // assuming 1024x768, minus chrome and such
    hSize = 1024; // these do not account for kiosk mode or Opera Show
  }
  var wscale = hSize /  image.origwidth;
  var hscale = vSize / image.origheight;
  scaleToFill = Math.min(wscale, hscale);

  if (! scaled)
    return;
  var scale = isNaN(zoomn) ? 1.0 : zoomn * scaleToFill;
  image.style.width = (scale * image.origwidth) + "px";
  image.style.height = (scale * image.origheight) + "px";
}

function handler(e) {
  var event = e ? e : window.event;
  var key = event.keyCode ? event.keyCode : event.which;
  if (event.ctrlKey || event.altKey || event.metaKey || zoomInputFocused)
    return;
  var shifted;
  if (key >= 65 && key <= 90) { key += 32; shifted = true; }
  else if (event.shiftKey) shifted = true;
  if (key == 32 || key == 34) { // space or page-down
    var body = document.body;
    if (nextId && (scaled || body.scrollTop+body.clientHeight>=body.scrollHeight))
      key = 110;
    else
      return true;
  }
  if (nextId && key == 110) { // 'n' key
      if (top.slider) {
        top.slider.sliderSelectCurStyle(nextId);
        return false;
      }
      location=nextId+style_link+".html"+hash;
      return true;
  }
  if (key == 33) { // page-up
    var body = document.body;
    if (prevId && body.scrollTop==0)
      key = 112;
    else
      return true;
  }
  if (prevId && key == 112) { // 'p' key
      if (top.slider) {
        top.slider.sliderSelectCurStyle(prevId);
        return false;
      }
    location=prevId+style_link+".html"+hash; return true;
  }
  if (key == 117) /* u==Up */ { top.location="index.html"+uphash; return true; }
  if (key == 115) /* 's' */ {
    location="slider.html#"+thisId+(shifted ? "/large-scaled" : "/medium-scaled");
    return true; }
  if (key == 105) /* 'i' */ { location=thisId+"info.html"; return true; }
  if (key == 108) /* 'l' */ { location=thisId+"large.html#large-scaled"; return true; }
  if (key == 109) /* 'm' */ { location=thisId+".html"; return true; }
  if (key == 104 ) { /* 'h' */
    toggleHidePreamble();
    return true;
  }
}

function toggleHidePreamble() {
  hidePreamble = !hidePreamble;
  preamble.style.visibility = hidePreamble ? "hidden" : "visible";
  UpdateLocationHash();
  StyleFixLinks();
}

document.onkeydown = handler;
//document.onkeypress = handler;

// No longer used - only so old pages don't die.
function StyleMenu() { return ""; }

// FIXME
//document.write("<style>span[style-button] { display: none }</style>");

// FIXME - add credit
function drag(elementToDrag, event) {
    // The mouse position (in window coordinates)
    // at which the drag begins 
    startX = event.clientX;
    startY = event.clientY;    

    // The original position (in document coordinates) of the
    // element that is going to be dragged.  Since elementToDrag is 
    // absolutely positioned, we assume that its offsetParent is the
    // document body.
    origX = elementToDrag.offsetLeft;
    origY = elementToDrag.offsetTop;

    // Even though the coordinates are computed in different 
    // coordinate systems, we can still compute the difference between them
    // and use it in the moveHandler() function.  This works because
    // the scrollbar position never changes during the drag.
    deltaX = startX - origX;
    deltaY = startY - origY;

    // We've handled this event. Don't let anybody else see it.  
    event.stopPropagation();  // DOM Level 2

    event.preventDefault();

    imageMoved = false;

    /**
     * This is the handler that captures mousemove events when an element
     * is being dragged. It is responsible for moving the element.
     **/

}
