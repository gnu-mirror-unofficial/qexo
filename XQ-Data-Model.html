<!--Copyright 2002 (C) Per Bothner.  <per@bothner.com>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, version 1.1.
A copy of the latter is in the file fdl.txt in this directory;
you may not distribute this document without it.-->
<html><body>
<p>If you find a mistake, or something is unclear, please email <a href="mailto:per@bothner.com">per@bothner.com</a> so I can fix the text.</p><h1>The XQuery Data Model and Types</h1>
<h2>by Per Bothner</h2>
<p>We have earlier looked at the values (nodes, primitives, and sequences) that XQuery works with. In this article we will look more deeply into the XQuery/XPath data model and type
system. On the way we will touch on a fair bit of background material, including XML Schemas and XML infosets.</p>
<h2>XML Infosets</h2>
<p>The XQuery data model is based on the XML Information Set standard (W3C Recommendation 24 October 2001, <a href="http://www.w3.org/TR/xml-infoset">http://www.w3.org/TR/xml-infoset</a>). It rather abstractly defines the
information content of an XML document as a document item that contains nested element items, which in turn contain namespace, attribute, character and other items. This is a conceptual standard: It
does not define any file formats or programming interfaces, but rather it defines the <i>interpretation</i> of an XML file. It is intended to be useful for defining other XML-related standards,
including the XQuery/XPath data model.</p>
<p>XML files that are different at the character level but that have the same information set or <i>infoset</i> are for most practical purposes equivalent. For example:</p>
<pre>&lt;a   b='upcase'  &gt;&lt;![CDATA[Hello!]]&gt;&lt;/a&gt;</pre>
<p>and</p>
<pre>&lt;a b="upcase" &gt;Hello&amp;#33;&lt;/a&gt;</pre>
<p>have the same information sets.</p>
<p>The <a href="http://www.w3.org/TR/2001/REC-xml-c14n-20010315">"Canonical
 XML" recommendation</a> is a related standard in that it specifies
a unique ("canonical") way to convert an XML infoset (back) into an
XML document.  Two XML documents that are "logically equivalent"
(i.e. have the same infoset) translate to the same canonical XML
representation. The Canonical XML for the above example is:</p>
<pre>
&lt;a b="upcase"&gt;Hello!&lt;/a&gt;
</pre>
<p>A parsed XML file results in an infoset, but there can also be <i>synthetic infosets</i> that are constructed from other sources, such as a database, or created by a program that
manipulates a DOM (Document Object Model). A DOM is a popular data structure API used to encode and manipulate XML data - i.e. infosets.</p>
<p>The XQuery language also allows you to create <i>infoset items</i>, using element constructor expressions or pre-defined functions.</p>
<h2>Node Values and Types</h2>
<p>Node values represent the parts of a XML document, or more generally an XML infoset. Nodes are also used to represent <i>document fragments</i> - i.e. stand-alone nodes that are not
part of a document (for example, those that might be generated by an element constructor expression).</p>
<p>These are the kinds of nodes, most of which are as you would expect:</p>
<ul>
<li><p>   <i>Document</i> nodes represent a complete XML document.</p></li>
<li><p>   <i>Element</i> nodes present XML elements.</p></li>
<li><p>   <i>Attribute</i> nodes represent the attributes of an element.  Note that namespace definitions are represented by namespace nodes instead.</p></li>
<li><p>   <i>Namespace</i> nodes represent the in-scope attributes of an element.  (You cannot actually "get at" a namespace node in XQuery,
though you get at them in XPath using the <code>namespace::</code>
axis, which has been deprecated in XPath 2.0.) </p></li>
<li><p>   <i>Processing instruction</i> nodes represent embedded XML processing instructions.</p></li>
<li><p>   <i>Comment</i> nodes represent XML comments.</p></li>
<li><p>   <i>Text</i> nodes represent character data. Note that an infoset consists of single-character items, but in the node representation multiple contiguous character items
are represented in a single text node.</p></li>
</ul>
<p>The <i>XQuery 1.0 and XPath 2.0 Data Model</i> specification (<a href="http://www.w3.org/TR/query-datamodel/">http://www.w3.org/TR/query-datamodel/</a>) goes into details about the different kinds of nodes. It also defines a
number of functions on nodes, using the prefix <code>dm</code>. For example, the function <code>dm:node-kind</code> takes a <code>Node</code> and returns a string value that represents the node's kind, one of
<code>"document"</code>, <code>"element"</code>, <code>"attribute"</code>, <code>"text"</code>, <code>"namespace"</code>, <code>"processing-instruction"</code>, or <code>"comment"</code>.
Note that these functions are only to explain the data model:
You cannot call them from an XQuery program, and
the prefix  <code>dm</code> isn't actually bound to any namespace.
However, in some cases there may be a
function in the <i>Functions and Operators</i> document
with the same name and behavior.  Those <em>are</em> available to
your XQuery programs.
For example there is a <code>fn:node-kind</code> function which
you can use, and which is defined to return the same
result as <code>dm:node-kind</code>.
</p>
<h3>Node identity and hierarchy</h3>
<p>Nodes in XQuery are <i>immutable</i>, which means you cannot change any part of a node once it has been created. This makes sense, since XQuery is a pure side-effect-free expression
language. However, nodes do have <i>identity</i>: two nodes that
were created using different expressions are distinct nodes,
even if they contain the same data.
You can compare the latter using the standard function
<code>fn:deep-equal</code>.
The following examples are all <code>true</code>:</p>
<pre>
fn:deep-equal(&lt;a&gt;test&lt;/a&gt;, &lt;/a&gt;test&lt;/a&gt;)
&lt;a&gt;test&lt;/a&gt; isnot &lt;/a&gt;test&lt;/a&gt;
let $x := &lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; return $x/b is $x/*</pre>
<p>Because nodes have identity, you can talk about making a copy of a node, because you can distinguish the original from the copy. However, atomic values do not have identity: There is no
way to copy the string <code>"xyzzy"</code> because there is no way to distinguish the copy from the original. That is the difference between a string atomic value and a text node, which you <i>can</i>
copy.</p>
<p>A node may have <i>children</i>, which are the nodes below it in the tree hierarchy, but not including attribute or namespace nodes.
For example, the children of an element node are the text nodes and
nested elements (and occasionally other nodes) that are its contents.
The function <code>dm:children</code> takes a node and returns the sequence of its children.
(This function only exists in the data model; to get the children of a node
<var>N</var> in XQuery use the expression <code>N/node()</code>.)
Only document and element nodes can have children, so
<code>dm:children</code> returns the empty sequence for other node types.</p>
<p>For each node <code>X</code> that is a child of <code>Y</code>, the node <code>X</code> has a <i>parent</i> property that is the node <code>Y</code>.
Using the data model, you can get at <code>Y</code> using the
<code>dm:parent</code> function; in an XQuery program
you have to use the expression <code>X/parent::node()</code>.
These properties have some surprising consequences. Because nodes are immutable, you have to specify the children of an element or document when you create it. However, those children
have to have their parent property set to the new node - but you can't modify them, as they are immutable. This chicken-and-egg problem is solved by creating new copies of the children, with
the parent property of the new nodes set to the new parent. Any children of the children also have to be copied.</p>
<p>Note, however, that this copying of nodes is part of the specification, but an implementation is free to optimize away the copying if it doesn't change the result. For example, consider
the following expression:</p>
<pre>&lt;a&gt;Some &lt;b/&gt;{&lt;c&gt;text&lt;/c&gt;}&lt;/a&gt;</pre>
<p>The specification says that <code>&lt;b&gt;</code> and <code>&lt;c&gt;</code> nodes are created, and then copied when <code>&lt;a&gt;</code> is created. But since there is no way to access the old
<code>&lt;b&gt;</code> and <code>&lt;c&gt;</code> nodes, an implementation is free to just re-use the old nodes without copying them, or it can create them in-place at the same time it creates <code>&lt;a&gt;</code>.
This is an example of the important difference between specification and (valid) implementation. The lack of side effects in XQuery gives the implementation extra flexibility in choosing how to
implement things. A possible disadvantage is that it makes it hard to estimate how much work is done for an XQuery program, unless you are very familiar with your implementation. On the other hand,
you usually don't need to know.</p>
<p>More generally, an implementation is free to represent nodes in any way compatible with the specification. An obvious choice is to use the standard <code>Node</code> type specified in the
W3C's Document Object Model (DOM) (<a href="http://www.w3.org/DOM">http://www.w3.org/DOM</a>). However, though DOM is a flexible and convenient API, it is quite space-inefficient. As an example of an alternative representation,
the Qexo implementation (<a href="http://www.gnu.org/software/qexo/">http://www.gnu.org/software/qexo/</a>) uses a single <code>TreeList</code> for an entire document. The <code>TreeList</code> contains an internal array, and node objects are
identified by indexes into that array. (The Apache Xalan XSLT processor uses a similar Document Array Model representation.) In fact, an implementation may in some cases not create actual node
objects at all. Consider that the ultimate result of evaluating an XQuery expression is often written out to a file as a new XML document. In that case the XQuery processor can write out the nodes
on-the-fly directly to the output file, without ever creating any nodes. More generally, the XQuery processor can "write" the output to a SAX <code>DocumentHandler</code> or a similar event-driven
interface.</p>
<h3>String value and typed value of nodes</h3>
<p>Sometimes it is useful to take a node, and convert it to a <i>string value</i>. The function <code>fn:string</code> does that. The string value of a text node is the characters in the
node. The string value of an element or document node is the concatenation of the text node descendents of the node in document order. The string value of an attribute node is the attribute
value.</p>
<p>There is also the <i>typed value</i> of an element, attribute, or text node, which you can extract using the <code>fn:data</code> function. This is the value of a node as a sequence of
atomic values, as the result of Scheme validation. If an element node has a complex type, then the typed value is undefined.</p>
<h2>Types and Type Systems</h2>
<p>The XQuery and XPath languages are typed expression (functional) languages. This means that programs are made from expressions (which may in turn contain sub-expressions), and that
evaluating an expression results in a value, which has a type.</p>
<p>Informally, a type is a set of values: those values that are <i>instances of</i> or <i>belong to</i> the type. The <i>type system</i> of a programming language is the collection
(vocabulary) of types that the language definition distinguishes, including the rules for determining whether a value is an instance of a type, and for how to create complex types from simple
types.</p>
<p>A <i>type error</i> occurs when the operands of an operation have types that are not allowed for that operation. For example, in XQuery you can add two numbers using the <code>+</code>
operator, but you can't add two nodes, even if the nodes contain integer values. If your program tries to add two nodes, the XQuery processor should give you an error message instead.</p>
<p>It is useful to distinguish between the dynamic types and static types:</p>
<ul>
<li><p>   The type of a <i>value</i> is a dynamic type. Dynamic types exist during evaluation (at run-time). Dynamic types are sets of values that are <i>instances</i> of the
type. A type specifies the meaning or interpretation of a value.</p></li>
<li><p>   The type of an <i>expression</i> (a program fragment) is a static type. Static types are the types of declarations and program fragments as specified by the programmer
or inferred by a compiler.  If an expression has a (static) type and you evaluate the expression without a run-time error, then the result is guaranteed to be an instance of the corresponding
static type.</p></li>
</ul>
<p>A <i>dynamically typed</i> language is one that doesn't have static types. Another way to say the same thing is that there is only a single type, which contains all values. In those
languages, all type errors are run-time errors. The goal of a static type system is to detect type errors at compile time, before actual execution. This is a process called <i>type checking</i>, and
in some languages (including XQuery) is a fairly complicated process.</p>
<p>Static type checking lets you detect and fix errors earlier. This is especially valuable for infrequently executed parts of a program, since they are less likely to get much testing. As
a side benefit, if the compiler can determine the type of an expression, it may be able to generate more efficient code, and so the query may execute faster.</p>
<p>The XQuery and XPath languages specify both dynamic types and static types. The static type checking is optional, both for implementors and users: An XQuery implementation need not
implement the static typing feature, and implementations that do implement static typing will have an option to disable it.</p>
<p>We will discuss static typing later, but first we will study dynamic typing, including the kinds of values that  XQuery and XPath deal with. The data model is part of dynamic
typing.</p>
<h2>The Data Model: Items and Sequences</h2>
<p>The values worked on by an XQuery program are <i>sequences</i> of <i>items</i>. An item is either an atomic value (for example an integer or a string) or a node (for example an element
or an attribute).</p>
<p>A sequence is a collection of zero or more items. The most important idea to note is that not only are all sequences values, but also all values are sequences, because a sequence of
just a single value is in all respects the same as the single value. It follows from this that you cannot nest sequences - you cannot have sequences of sequences, only flat single-level
sequences.</p>
<p>If you have experience with arrays or lists in other programming languages, you might think it is a strange and limiting restriction that you can't nest sequences. Actually, it isn't
really a limitation, because you can always uses nested elements if you need nested data. For example, to represent a two-dimensional array you can use nested elements like this:</p>
<pre>&lt;list&gt;
  &lt;list&gt;11 12&lt;/list&gt;
  &lt;list&gt;21 22&lt;/list&gt;
&lt;/list&gt;</pre>
<p>A major difference between XPath 1 and XPath 2 is that the latter has sequences, while the former does not. Instead, XPath 1 has <i>node sets</i>, which are like sequences, but without
duplicates, and in unspecified order. XPath 1 path expressions evaluate to node sets, while in XPath 2 (and XQuery) path expressions evaluate to node sequences. However, the latter sequences are
defined to be sorted in document order and with duplicates removed. (These are actually equivalent, in that you can map a set into a sequence that is ordered and without duplicates, and back again,
without information loss. Furthermore, any valid XPath 1 expression will behave the same under either model.)</p>
<h2>Atomic Values and Types</h2>
<p>The XQuery/XPath primitive types are the same as in XML Schema, which is a standard for specifying element structure of XML data, and associating types with XML data.</p>
<p>Atomic values include numbers, values, and booleans. There are two kinds of atomic type:</p>
<ul>
<li><p> A <i>primitive type</i> is not defined in terms of some other type.</p></li>
<li><p> A <i>derived type</i> is based on some other type, its <i>base type</i>.</p></li>
</ul>
<p>A derived atomic type is a <i>restriction</i> of its base type, because it is a restriction (sub-set) of the set of atomic values that belong to the base type.</p>
<p>Following is a complete list of the built-in types defined by XML Schema. We will only list them briefly; for more information see the W3C Recommendation (02 May 2001) of X<i>ML Schema
Part 2: Datatypes</i> (<a href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</a>). This specifies for each type its <i>value space</i> (the abstract values that belong to the type), its <i>lexical space</i> (the text
representation of values using printable characters), and its facets (properties of the type itself).</p>
<p>XML Schema defines the following builtin types:</p>
<ul>
<li><p> A <code>boolean</code> is one of the two truth values <code>true</code> and <code>false</code>.</p></li>
<li><p> A <code>string</code> is zero or more Unicode characters.</p></li>
<li><p>   There a various sub-types of <code>string</code>: A <code>normalizedString</code> is a <code>string</code> that does not have any whitespace characters except for space. A <code>token</code>
is a <code>normalizedString</code> that has no leading or trailing spaces, and does not have two or more spaces in a row. A <code>language</code> is a <code>token</code> used to specify a natural (human) language. An
<code>NMTOKEN</code> is a <code>token</code> consisting of one or more <code>NameChar</code> characters, as defined in the XML standard. A <code>Name</code> is a <code>token</code> used to represent XML names, such as <code>body</code>
or <code>html:table</code>. An <code>NCName</code> is a plain <code>Name</code> without a colon, such as <code>body</code>. The types <code>ID</code>, <code>IDREF</code>, and <code>ENTITY</code> are sub-types of <code>NCName</code> used for
special kinds of attribute values as specified in the XML standard. The types <code>IDS</code>, <code>IDREFS</code>, <code>ENTITIES</code>, and <code>NMTOKENS</code> are used for space-separated sequences of the
corresponding tokens.</p></li>
<li><p> A <code>NOTATION</code> is used for attributes that specify the notation (encoding) of an element. However, <code>NOTATION</code> is not a sub-type of <code>string</code>.</p></li>
<li><p> An <code>anyURI</code> represents a Uniform Resource Identifier Reference, such as <a href="http://www.w3.org/">http://www.w3.org/</a>.</p></li>
<li><p> A <code>QName</code> represents an XML qualified name, which is a pair of a <i>namespace name</i>, and a <i>local part</i>. Note that in the value space a namespace name is an
<code>anyURI</code> (such as <a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>), while the lexical representation uses namespace prefixes (as in <code>xhtml:body</code>). Therefore mapping between the two requires a context
that contains the needed <i>namespace declaration</i>.</p></li>
<li><p> A <code>decimal</code> is an arbitrary-precision real number, in base 10. An <code>integer</code> is a <code>decimal</code> without a fractional part. The types <code>nonPositiveInteger</code>,
<code>negativeInteger</code>, <code>nonNegativeInteger</code>, and <code>positiveInteger</code> are the obvious sub-types of <code>integer</code>. The types <code>long</code>, <code>int</code>, <code>short</code>, <code>byte</code>,
<code>unsignedLong</code>, <code>unsignedInt</code>, <code>unsignedShort</code>, and <code>unsignedByte</code> are sub-types of <code>integer</code> that can be encoded in binary using respectively 64, 32, 16, or 8 bits.</p></li>
<li><p>   The types <code>float</code> and <code>double</code> correspond to 32-bit and 64-bit IEEE binary floating-point real numbers. The standard lexical representation uses decimal
format, with an optional exponent, such as <code>-58.45</code> or <code>1.25e-10</code>, even though these types are not sub-types of <code>decimal</code>.</p></li>
<li><p>   There are a number of time-related types: A <code>date</code> is a calendar date, such as May 31, 1999 (written <code>1999-05-31</code>).  A <code>time</code> is an instant that
occurs every day, like 1:20pm (written <code>13:20</code>). A <code>dateTime</code> is a specific instant of time, like 1:20pm on May 31 1999 (written as <code>1999-05-31T13:20</code>). Any of these may have an
optional timezone specified. A <code>gYear</code> is a specific year in the Gregorian calendar, while a <code>gMonthYear</code> is a specific year and month. A <code>gMonthDay</code> is a month and day that recurs
every year, a <code>gMonth</code> is a month that recurs every year, and a <code>gDay</code> is a day that recurs every month. A <code>duration</code> is a duration of time, like 2 days and 1 hour (written as
<code>P2D1H</code>). The XQuery/XPath committee has added two sub-types of <code>duration</code>, which may get added to future Schema revisions: <code>xdt:yearMonthDuration</code> (a duration of some number of years and
months) and <code>xdt:dayTimeDuration</code> (a duration of some number of days, hours, minutes, and seconds).</p></li>
<li><p>   The types <code>hexBinary</code> and <code>base64Binary</code> are used to encode arbitrary binary data. The value of either is zero or more octets (8-bit bytes). A
<code>hexBinary</code> uses two hexadecimal digits for each octet, so <code>0FB7</code> encodes the 16-bit integer 4023. A <code>base64Binary</code> uses the Base64 MIME Content-Transfer-Encoding.</p></li>
</ul>
<p>The union of all primitive types is <code>anySimpleType</code>.</p>
<p>All of these standard types names are in the <code>http://www.w3.org/2001/XMLSchema</code> namespace, conventionally written using the predefined namespace prefix <code>xs</code>, as in <code>xs:string</code>.</p>
<p>
The XQuery specication adds four types:
the duration types <code>xdt:yearMonthDuration</code> and
<code>xdt:dayTimeDuration</code> are mentioned above;
<code>xdt:anyAtomicType</code> includes all the atomic values;
and <code>xdt:untypedAtomic</code> is a type used for untyped data,
such as text that has not been validated. 
All are subtypes of <code>anySimpleType</code>, and are
in the <code>http://www.w3.org/2003/05/xpath-datatypes</code> namespace.

<h2>Schemas and complex types</h2>
<p>The word <i>schema</i> comes from the database community, and means a description of the structure, types, and relations of a database. In the XML world a schema is a description of the
syntax and meaning (types) of a class of XML documents. A schema language is a formalism for specifying the types of documents as schemas.</p>
<p>The earliest XML schema language is DTD (Document Type Descriptor), which appears in the original XML specification from 1997, and goes back to the SGML roots of XML.  DTD is a
simple language that lets you express simple structural constraints.  For example, the following:</p>
<pre>&lt;!ELEMENT tr td*&gt;</pre>
<p>means that a <code>&lt;tr&gt;</code> element consists of zero or more <code>&lt;td&gt;</code> elements.</p>
<p>DTD does not have any mechanism for specifying semantic or type information, except in a very few cases. Other schema definition languages allow you to define and specify types.</p>
<p>XML Schema (<a href="http://www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a>) is a 2001 specification from W3C that can be used to specify structural constrains and associate type information with XML documents.
While there are other Scheme language in use, this is the one with most usage and visibility, partly because it is a W3C standard. The type semantics of XQuery/XPath2 are defined in terms of XML
Schema.</p>
<p>As an example we will use the record of a series of dice throws.  Perhaps you want to verify the dice are fair, or you want a source of random numbers, or you want search for
mystical patterns.</p>
<pre>&lt;?xml version="1.0"?&gt;
&lt;die-tests&gt;
  &lt;die-test&gt;
    &lt;who&gt;Nathan&lt;/who&gt;
    &lt;when&gt;whenever&lt;/when&gt;
    &lt;throws&gt;5 2 2 2 1 3 6 6 2 6&lt;/throws&gt;
  &lt;/die-test&gt;
  &lt;die-test&gt;
    &lt;who&gt;Per&lt;/who&gt;
    &lt;when&gt;2002-10-09T09:07&lt;/when&gt;
    &lt;throws&gt;6 2 5 2 2 3 3 3 4 1&lt;/throws&gt;
  &lt;/die-test&gt;
&lt;/die-tests&gt;</pre>
<p>The Schema for this might look like the following:</p>
<pre>&lt;?xml version="1.0"?&gt;
&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xsd:element name="die-tests"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="die-test" type="die-test-type"
          minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="die-test-type"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="who" type="xsd:string"/&gt;
      &lt;xsd:element name="when" type="xsd:dateTime"/&gt;
      &lt;xsd:element name="throws"&gt;
        &lt;xsd:simpleType&gt;
          &lt;xsd:list itemType="die6-result"/&gt;
        &lt;/xsd:simpleType&gt;
      &lt;/xsd:element&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:simpleType name="die6-result"&gt;
    &lt;xsd:restriction base="xsd:integer"&gt;
      &lt;xsd:minInclusive value="1"/&gt;
      &lt;xsd:maxInclusive value="6"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;
&lt;/xsd:schema&gt;</pre>
<p>This is verbose, and may be a bit intimidating, but it is relatively straightforward. It contains a top-level <i>element declaration</i> for the root element <code>&lt;die-tests&gt;</code>,
as well as <i>type definitions</i> for types named <code>die-test-type</code> and <code>die6-result</code>. The difference between a <i>complex type</i> (such as <code>die-test-type</code>) and a <i>simple type</i>
(such as <code>die6-result</code>) is that a simple type can only be expressed as character data, while a complex type can consist of sub-elements and attribute specifications. The type of an attribute can
only be a simple type, while the type of an element can be either a simple type (if it only contains text data), or it can be a complex type. All pre-defined types (such as <code>xsd:integer</code>) are
simple.</p>
<p>The top-level element declaration for <code>die-tests</code> says that any element with the <code>die-tests</code> tag has the structure and type specified: It is a complex type consisting of a
sequence of 0 or more elements that have the tag <code>die-test</code>, and that the content of each such <code>die-test</code> element has the type with the name <code>die-test-type</code>. (It is possible to specify
that a given element tag can be have different types in different contexts, but we'll ignore that possibility.)</p>
<p>The definition of the complex type <code>die-test-type</code> specifies that any element declared to have that type (in our case <code>die-test</code>) consists of a sequence of a
<code>&lt;name&gt;</code> element, a <code>&lt;when&gt;</code> element, and a <code>&lt;throws&gt;</code> element. The latter is a space-separated list of <code>die6-result</code> values. The definition for the simple type
<code>die6-result</code> says that a <code>die-result</code> is an <code>integer</code> in the range 1 through 6.</p>
<h2>Validation produces type annotations</h2>
<p>To <i>validate</i> an XML document against a schema means to scan the document, verifying that the document satisfies the constraints specified in the schema.  The result is a
<i>post-schema validation infoset</i> (PSVI), which is an info set (as defined earlier) with additional <i>type annotations</i>.   A type annotation is the QName of a type named in a
schema.</p>
<p>An XQuery processor may optionally implement the <i>Schema import feature</i>. If it does, it must be able to import definitions from external schemas and validate node trees.</p>
<p>Each element or attribute in XQuery has a <i>type annotation</i>, which is its <i>dynamic type</i>. If an element has not been validated, or otherwise been given a type annotation, then
it has the default type annotation <code>xs:anyType</code>. The corresponding
default for an attribute node is the type <code>xs:untypedAtomic</code>.</p>
<p>Atomic (non-node) values can also have type annotations.  The annotation <code>xsd:untypedAtomic</code> indicates that the type is unknown, typically
raw text from an schema-less XML file.  Operations that take atomic values may
cast <code>xsd:untypedAtomic</code> to a more specific type, such as <code>xs:double</code>, but if the atomic value is of the wrong kind (a string where a number is required, as in the operands of <code>+</code>),
then a run-time error may be signaled.</p>
<p>An XQuery application can use a validate expression:</p>
<pre>validate ( EXPR )</pre>
<p>This takes a sequence of elements, strips off any existing type annotations, and adds type annotations as specified by the <i>in-context scheme definitions</i>. The latter are all the
scheme element declarations and type definitions that are imported by schema import declarations. (You can optionally specify a SchemaContext that can be used with context-dependent schema
types.)</p>
<p>A schema import declaration appears in the Query Prolog of an XQuery program. For example:</p>
<pre>import schema "http://www.w3.org/1999/xhtml" at "xhtml.xsd"</pre>
<p>This tells the XQuery processor to look at the location specified (in this case by the relative URL "<code>xhtml.dtd</code>") and add any schema components in the specified namespace
(<a href="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</a>) to the set of visible schema components. These now become available for <code>validate</code> expressions.</p>
<p>Note that Schema validation and type annotation are conceptually dynamic (run-time) type operations.  A type annotation is a QName that is associated with a value, not associated
with a static (compile-time) expression.  Next we will look at static type-checking.</p>
<h2>Sequence Types</h2>
<p>The XQuery language provides operations to check whether a value belongs to a type, as well as mechanisms to declare that a variable or parameter has a specific type. In an XQuery
program (static) types are instances of <code>SequenceType</code>. We won't go into detail about <code>SequenceType</code>, but here are some examples:</p>
<p><code>text()</code> &#8212; Matches any text node.</p>
<p><code>element()</code> &#8212; Matches any element node.</p>
<p><code>element(xhtml:td,*)</code> &#8212; Matches any element node whose tag has the local part <code>td</code> and has the same namespace URI that <code>xhtml</code> is bound to. (It does not have to have
<code>xhtml</code> as the actual namespace prefix.)</p>
<code>element(*, die6-result)</code> &#8212; Matches any element of any tag that has a type annotation of <code>die6-result</code>.</p>
<p>
<code>element(xhtml:title)?</code> &#8212; Matches an optional type
element - i.e. zero or one items that match element
<code>xhtml:title</code>, <em>and</em> whose type annotation matches
that declared for <code>xhtml:title</code> in an imported schema
definition.</p>
<p>
<p><code>node()*</code> &#8212; Matches a sequence of zero or more nodes.</p>
<p><code>item()+</code> &#8212; Matches any non-empty sequence.</p>
<p><code>attribute(@ID, *)</code> &#8212; Matches any attribute node whose name is <code>ID</code> (in the empty namespace).</p>
<p><code>xs:integer</code> &#8212; Matches any integer type or any type derived from it, such a <code>xs:nonNegativeInteger</code>, assuming this is in scope of a namespace declaration that binds
<code>xsd</code> to  <a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a>.</p>
<p>These types can be used for XQuery's type-checking and -conversion operators.  Here is a very brief summary; see the specification or other chapters for details and
examples.</p>
<p><code>expr instance of type</code> &#8212; Returns true if the value of <code>expr</code> matches (is an instance of) <code>type</code>.</p>
<p><code>cast as type (expr)</code> &#8212; Convert the value of <code>expr</code> to a given <code>type</code>, using certain standard conversions.</p>
<p><code>treat as type (expr)</code> &#8212; Treat the <code>expr</code> as having static type <code>type</code>. At run-rime, a dynamic error is signaled if the value of <code>expr</code> is not an instance of
type.</p>
<p><code>typeswitch (expr) case type1 return expr1 ... default return exprd</code> &#8212; Select the first <code>case</code> whose type matches the value of the <code>expr</code>, and evaluate the
corresponding expression.</p>
<h2>Static typing</h2>
<p>An XQuery implementation may optionally implement the <i>Static Typing Feature</i>. This means that the implementation is required to detect static type errors at analysis (compile)
time. At the time of this writing, the specification has a number of unresolved issues, and I don't know of any implementation that actually does implement static typing. (However, some of the
precursor languages that inspired XQuery do implement static typing.) For these reasons, plus the fact that the specification of static typing is big and formal, I won't go beyond mentioning a few
of the concepts.</p>
<p>The static type system defined in the XQuery formal semantics (<a href="http://www.w3.org/TR/query-semantics/">http://www.w3.org/TR/query-semantics/</a>) goes far beyond what you can express as a S<code>equenceType</code>. It includes
most of the type specification concepts of XML Schema. The formal semantics defines extra declarations <code>define type</code>, <code>define element</code>, and <code>define attribute</code>. These are <i>not</i> in
the XQuery source language (i.e. you can't write them directly), but are a formalism used in the formal semantics to express types imported from schemas. The idea is that an XQuery program is
translated to <i>core XQuery</i>, which is simpler and more regular (but less convenient) than the actual XQuery program. Part of this translation is that Scheme import declaration are translated
into <code>define type</code>, <code>define element</code>, and <code>define attribute</code> declarations. These internal declarations, as well as the whole concept of core XQuery, are purely part of the formal
specification of XQuery: There is no requirement that any implementation implement the translation to core XQuery, only that it acts <i>as if</i> it does.</p>
<p>Static type checking is done at the level of core XQuery at analysis (or compile) time. There are a whole slew of rules that say things like <i>if the type of</i> <code>expr1</code> <i>is</i>
<code>xsd:boolean</code><i>, the type of</i> <code>expr2</code> <i>is</i> <code>type2</code><i>, and the type of</i> <code>expr3</code><i>is</i> <code>type3</code>, <i>then the type of</i> <code>if (expr1) then expr2 else expr3</code>
<i>is</i> <code>(type2|type3)</code>. Here <code>(type2|type3)</code> is a type expression in the formal semantics, which you cannot write directly in the actual XQuery language.</p>

<hr />
<p>
Copyright 2002, 2003 (C) Per Bothner.  <code>&lt;<a href="mailto:per@bothner.com">per@bothner.com</a>&gt;</code></p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the <a href="fdl.txt">GNU Free Documentation License</a>,
version 1.1.</p>
</body></html>
